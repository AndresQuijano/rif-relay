
A simple proxy that delegates every call to an address.
This ProxyA is the one instantiated per smart wallet, and it will receive a ProxyB as MC. So every call
made to the ProxyA will end up in ProxyB.
ProxyB is controlled by the same developer who created the factory, and it's in charge of the signature verification and payment.
Then it will forward (delegatecall) the transaction to the Forwarder code, which will execute it.

====================================================================================================================================================
                                                            PROXY A
====================================================================================================================================================
                                                    Constructor
====================================================================================================================================================
PC | OPCODE|   Mnemonic     |   Stack [top, bottom]                      | Comments
----------------------------------------------------------------------------------------------------------------------------------------------------
1  | 60 2D | PUSH1 2D       | [45]                                       | Size of runtime code
3  | 3D    | RETURNDATASIZE | [0, 45]                                    | Before any external call, returdatasize = 0 (cheaper than PUSH1 00)
4  | 81    | DUP2           | [45, 0, 45]                                |
5  | 60 09 | PUSH1 09       | [9, 45, 0, 45]                             | Size of constructor code
7  | 3D    | RETURNDATASIZE | [0, 9, 45, 0, 45]                          | 
8  | 39    | CODECOPY       | [0, 45]                                    | Mem[0:44] = address(this).code[9:53]
9  | F3    | RETURN         | []                                         | return Mem[0:44]                   

====================================================================================================================================================
                                                    Runtime Code
====================================================================================================================================================
PC | OPCODE|   Mnemonic     |   Stack [top, bottom]                       | Comments
----------------------------------------------------------------------------------------------------------------------------------
1  | 36    | CALLDATASIZE   | [msg.data.size]                             |
2  | 3D    | RETURNDATASIZE | [0, msg.data.size]                          |
3  | 3D    | RETURNDATASIZE | [0, 0, msg.data.size]                       |
4  | 37    | CALLDATACOPY   | []                                          | Mem[0:msg.data.size-1] = msg.data[0:msg.data.size-1]
5  | 3D    | RETURNDATASIZE | [0]                                         |
6  | 3D    | RETURNDATASIZE | [0, 0]                                      |
7  | 3D    | RETURNDATASIZE | [0, 0, 0]                                   |
8  | 3D    | RETURNDATASIZE | [0, 0, 0, 0]                                |
9  | 36    | CALLDATASIZE   | [msg.data.size, 0, 0, 0, 0]                 |
10 | 3D    | RETURNDATASIZE | [0, msg.data.size, 0, 0, 0, 0]              |
11 | 73 MC | PUSH20 MC      | [mcAddr,0, msg.data.size, 0, 0, 0, 0]       | mcAddr = address of master Copy, injected by factory
32 | 5A    | GAS            | [rGas, mcAddr,0, msg.data.size, 0, 0, 0, 0] | rGas = remaining gas
33 | F4    | DELEGATECALL   | [isSuccess, 0, 0]                           | isSuccess, Mem[0:0] = address(mcAddr).delegateCall.gas(rGas)(Mem[0:msg.data.size-1])
34 | 3D    | RETURNDATASIZE | [rds, isSuccess, 0, 0]                      | rds = size of what the logic called returned
35 | 92    | SWAP3          | [0, isSuccess, 0, rds]                      |
36 | 3D    | RETURNDATASIZE | [rds, 0, isSuccess, 0, rds]                 |
37 | 90    | SWAP1          | [0, rds, isSuccess, 0, rds]                 |
38 | 80    | DUP1           | [0, 0, rds, isSuccess, 0, rds]              |
39 | 3E    | RETURNDATACOPY | [isSuccess, 0, rds]                         | Mem[0:rds-1] = RETURNDATA[0:rds-1]
40 | 60 2D | PUSH1 2D       | [45, isSuccess, 0, rds]                     |
42 | 57    | JUMPI          | [0, rds]                                    | if(isSuccess) then jump to PC=45
43 | FD    | REVERT         | []                                          | revert(Mem[0, rds-1])
44 | 5B    | JUMPDEST       | [0, rds]                                    |
45 | F3    | RETURN         | []                                          | return(Mem[0, rds-1])
